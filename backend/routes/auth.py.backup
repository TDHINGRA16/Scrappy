"""
Authentication Routes for Scrappy v2.0

BetterAuth-style endpoints:
- POST /api/auth/sign-up - Register new user
- POST /api/auth/sign-in - Login user
- POST /api/auth/sign-out - Logout user
- POST /api/auth/refresh - Refresh access token
- GET  /api/auth/me - Get current user
- PUT  /api/auth/me - Update current user
- POST /api/auth/change-password - Change password
"""

from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session
import logging

from models.schemas import (
    SignInRequest,
    SignUpRequest,
    AuthResponse,
    UserResponse,
    UserUpdateRequest,
    ChangePasswordRequest,
    RefreshTokenRequest,
    MessageResponse
)
from models.user import User
from services.auth_service import AuthService
from middleware.auth import get_current_user
from database import get_db

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api/auth", tags=["Authentication"])


@router.post("/sign-up", response_model=AuthResponse, status_code=status.HTTP_201_CREATED)
async def sign_up(
    request: SignUpRequest,
    db: Session = Depends(get_db)
):
    """
    Register a new user account.
    
    Returns access and refresh tokens upon successful registration.
    """
    try:
        # Register user
        user = AuthService.register_user(
            db=db,
            email=request.email,
            password=request.password,
            name=request.name
        )
        
        # Create tokens
        access_token, access_expire = AuthService.create_access_token(
            user_id=str(user.id),
            email=user.email
        )
        refresh_token, refresh_expire = AuthService.create_refresh_token(
            user_id=str(user.id),
            email=user.email
        )
        
        # Store session
        AuthService.create_session(
            db=db,
            user_id=str(user.id),
            refresh_token=refresh_token,
            expires_at=refresh_expire
        )
        
        logger.info(f"✅ User signed up: {user.email}")
        
        return AuthResponse(
            access_token=access_token,
            refresh_token=refresh_token,
            token_type="bearer",
            expires_in=int(access_expire.timestamp()),
            user=UserResponse(
                id=str(user.id),
                email=user.email,
                name=user.name,
                image=user.image,
                is_active=user.is_active,
                email_verified=user.email_verified,
                created_at=user.created_at
            )
        )
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.post("/sign-in", response_model=AuthResponse)
async def sign_in(
    request: SignInRequest,
    http_request: Request,
    db: Session = Depends(get_db)
):
    """
    Sign in with email and password.
    
    Returns access and refresh tokens upon successful authentication.
    This replaces the hardcoded credential check.
    """
    # Authenticate user (replaces hardcoded check)
    user = AuthService.authenticate_user(
        db=db,
        email=request.email,
        password=request.password
    )
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )
    
    # Create tokens
    access_token, access_expire = AuthService.create_access_token(
        user_id=str(user.id),
        email=user.email
    )
    refresh_token, refresh_expire = AuthService.create_refresh_token(
        user_id=str(user.id),
        email=user.email
    )
    
    # Store session with request info
    AuthService.create_session(
        db=db,
        user_id=str(user.id),
        refresh_token=refresh_token,
        user_agent=http_request.headers.get("User-Agent"),
        ip_address=http_request.client.host if http_request.client else None,
        expires_at=refresh_expire
    )
    
    logger.info(f"✅ User signed in: {user.email}")
    
    return AuthResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer",
        expires_in=int(access_expire.timestamp()),
        user=UserResponse(
            id=str(user.id),
            email=user.email,
            name=user.name,
            image=user.image,
            is_active=user.is_active,
            email_verified=user.email_verified,
            created_at=user.created_at
        )
    )


@router.post("/sign-out", response_model=MessageResponse)
async def sign_out(
    request: RefreshTokenRequest,
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Sign out and invalidate the current session.
    """
    # Invalidate the session
    AuthService.invalidate_session(db, request.refresh_token)
    
    logger.info(f"✅ User signed out: {user.email}")
    
    return MessageResponse(message="Successfully signed out")


@router.post("/sign-out-all", response_model=MessageResponse)
async def sign_out_all(
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Sign out from all devices (invalidate all sessions).
    """
    count = AuthService.invalidate_all_sessions(db, str(user.id))
    
    logger.info(f"✅ User signed out from all devices: {user.email} ({count} sessions)")
    
    return MessageResponse(message=f"Signed out from {count} sessions")


@router.post("/refresh", response_model=AuthResponse)
async def refresh_token(
    request: RefreshTokenRequest,
    db: Session = Depends(get_db)
):
    """
    Refresh access token using refresh token.
    """
    # Verify refresh token
    token_data = AuthService.verify_token(request.refresh_token)
    
    if not token_data:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    
    if token_data.token_type != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token type"
        )
    
    # Get user to verify still active
    user = AuthService.get_user_by_id(db, token_data.user_id)
    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found or inactive"
        )
    
    # Create new tokens (token rotation)
    access_token, access_expire = AuthService.create_access_token(
        user_id=str(user.id),
        email=user.email
    )
    new_refresh_token, refresh_expire = AuthService.create_refresh_token(
        user_id=str(user.id),
        email=user.email
    )
    
    # Invalidate old session and create new one
    AuthService.invalidate_session(db, request.refresh_token)
    AuthService.create_session(
        db=db,
        user_id=str(user.id),
        refresh_token=new_refresh_token,
        expires_at=refresh_expire
    )
    
    return AuthResponse(
        access_token=access_token,
        refresh_token=new_refresh_token,
        token_type="bearer",
        expires_in=int(access_expire.timestamp()),
        user=UserResponse(
            id=str(user.id),
            email=user.email,
            name=user.name,
            image=user.image,
            is_active=user.is_active,
            email_verified=user.email_verified,
            created_at=user.created_at
        )
    )


@router.get("/me", response_model=UserResponse)
async def get_me(user: User = Depends(get_current_user)):
    """
    Get current authenticated user's profile.
    """
    return UserResponse(
        id=str(user.id),
        email=user.email,
        name=user.name,
        image=user.image,
        is_active=user.is_active,
        email_verified=user.email_verified,
        created_at=user.created_at
    )


@router.put("/me", response_model=UserResponse)
async def update_me(
    request: UserUpdateRequest,
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Update current user's profile.
    """
    updated_user = AuthService.update_user(
        db=db,
        user_id=str(user.id),
        name=request.name,
        image=request.image
    )
    
    if not updated_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return UserResponse(
        id=str(updated_user.id),
        email=updated_user.email,
        name=updated_user.name,
        image=updated_user.image,
        is_active=updated_user.is_active,
        email_verified=updated_user.email_verified,
        created_at=updated_user.created_at
    )


@router.post("/change-password", response_model=MessageResponse)
async def change_password(
    request: ChangePasswordRequest,
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Change current user's password.
    """
    success = AuthService.change_password(
        db=db,
        user_id=str(user.id),
        current_password=request.current_password,
        new_password=request.new_password
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Current password is incorrect"
        )
    
    # Optionally invalidate all other sessions
    if request.logout_all_devices:
        AuthService.invalidate_all_sessions(db, str(user.id))
    
    return MessageResponse(message="Password changed successfully")
